1. 框架底层看过没?

	(1)异常类:

	   通过重写底层类的render方法实现了json数据格式返回。
	   在重写的render方法里面做了一些逻辑处理。

	(2)IOC服务容器（控制反转或依赖注入）:

       总结: 容器就是用来传递应用所依赖的对象。
       实现: php的反射是容器的实现基础。 《《底层代码中里面也是递归解决依赖的。》》
       服务提供者: 容器做好了。那么就要往里面放类服务了。服务提供者就是做这个的。
			        服务提供者是Laravel应用启动的中心位置
			        Laravel应用和核心服务都是通过服务提供者启动的
			        服务提供者是配置应用的中心位置
       			  ① 建立一个需要用到的类（服务类） class demo{function test(echo 1)} 
       			  ② 创建服务提供者 php artisan make:provider FooServiceProvider
       			  ③ 注册服务提供者 config/app.php 中间的 providers属性中注册
       			  ④ 测试服务提供者 dd(demo::test())
       依赖注入的方式使用容器:

    (3)门面:

       使用方法:
       	   ① 创建一个测试的类
       	   ② 创建一个服务提供类。注册这个测试的类。
       	   ③ 注册服务提供类。
       	   ④ 创建一个门面  继承 Facade类。并重写getFacadeAccessor方法
       	   ⑤ 在app.php中注册门面
       	   ⑥ 调用使用这个门面。 
       优点:
       	   （1）不需要创建实例。
       缺点: 
       		(1) 不容易追代码。


	(4)公共方法:

  		5.5之后bootstrap/autoload.php已经不存在了。
	  	1. 创建一个文件 /app/Helpers/function.php
	  	在composer.json中配置
	  	"autoload":{
	  		"files":[
	  			"app/Helpers/function.php"
	  		 ]
	  	}

  	(5)日志:

  		记录日志有很多通道
  		可以通过Log::channel('slack')自己选择通道
  		在config/logging.php 可以配置通道参数，如路径，

    (6)事件触发器:

    	使用场景:用户注册的时候发一些帮助邮件给用户
    	实现: 
    		① 在\app\Providers\EventServiceProvider.php中绑定k-v事件。
    		② 运行命令php artisan event:generate 生成
    		③ 在 'k' 中通过构造函数来做一些初始化
    		④ 在 'v' 中的hander中做一些逻辑处理
    		⑤ 通过 event() 使用。
    	源码流程: 
    		父类中 有个boot方法用来遍历这个k-v事件数组，
    		然后这块他对k-v进行绑定。使用了门面访问。
    		追到绑定的类中 里面经过一系列的调用,最后通过闭包的形式调用事件监听类中handl

2. mysql
  
   (1) mysql的索引?:	

   	   简介: 索引是一种数据结构，能够帮助我们快速的检索数据。

       什么时候适合使用索引?
          ① 数据量
          ② 慢查询
          

   	   索引的数据结构:
   	       ① hash索引:
   	       		 是 k-v 的结构，没有顺序可言，使用与等值查找。
   	       		 所以范围查找，排序，复合索引在hash上不适用。

   	       		 哈希碰撞?
   	       		 如果有重复的键值则会产生哈希碰撞。影响效率。

   	       ② B + tree索引:
   	       		 是一个平衡查找树，左小于父，父小于右。所以范围查询很合适

   	   5.6有的索引下推:

   	   	   默认开启.
   	   	   当（username,age）联合索引
   	   	   "select * from user_table where username like '张%' and age > 10". 
   	   	   开启索引下推比较快。

   	   为什么有时候没有用到索引?
   	   	   
   	   	   是因为mysql的执行计划的问题。

   (2) mysql的存储引擎有了解吗?简单介绍一下.
       有了解过innodb、myisam、csv。

   	   innodb
   	   	 特性: 可以热备份、是聚簇索引、支持事务、支持行锁(高并发合适)、支持外键、索引下推
   	   	 特性介绍:
   	   	 	
   	   	 	热备份: ibbackup工具、 XtraBackup工具.
   	   	 	聚簇索引: 存储时每张表都按主键顺序排放，没有主键时候则默认生成一个当做主键
   	   	 			 一个主键节点上挂着一行的数据。
   	   	 	支持事务: 对于一些需要事务的业务,选用innodb比较合适。
   	   	 	支持行锁: 在写数据的时候只对写的那些数据所在行加锁。面对高并发的时候也比较好。
   	   	 	支持外键:  外键是在从表中建立, 
   	   	 			      alert table 表名 add constraint FK_ID foreign key(外键字段名) references 外表表名(主键字段名)
   	   	 			  建立外键之后就有了约束。
   	   	 			     如你在从表中添加一个主表中没有的外键值,那么会失败。
   	   	 			     如你在主表删除一条从表依赖的一条数据，那么会失败。
   	   	 			  解除外键:
   	   	 			  	  alter table 表名 drop foreign key 外键名;


   	   myisam
   	   	 特性: 压缩(节省空间,提升查询速度,但是不能修改了)、空间函数、表锁(高并发不合适)、
   	   	          内置了统计计数器
   	   	 特性介绍:
   	   	    压缩: 
   	   	    空间函数:
   	   	    表锁: 对一张表中写数据的时候会将整个表锁住。对高并发支持不好。

   (3) 表结构设计及sql语句优化:
   		原则: 
   	   	 	1 字段尽量定常
   	   	 	2 常用字段和不常用字段分离
   	   	 	3 反范式，追加冗余字段（空间换时间）
   	   ① 选择合适的存储引擎:
   	   	 innodb  --->  事务、热备份、更新数据多行的时候（大数据量读写）。
   	   	 	
   	   	 myisam ---> 读取频繁、统计表的行数、不需要事务、
   	   	    
   	   	 不知道如何选择 ----> innodb

   	   ② 选择数据类型:
   	   	 1. 字段尽量要短 (节省空间,查询快)
   	   	 2. 能用int不用字符串。 (int是数字通用,快)
   	   	 3. 没有负数->非负,设置不为NULL。("NULL"占空间走索引,空值 不占)
   	   	 4. 尽量少用text类型，非用不可时最好考虑分表(???)
   	   	 5. ip 用int存, ip -> 转二进制(8位一个) -> 转10进制
   	   	 6. 枚举类型的选择。
		 7. timestamp和datetime都是精确到秒，优先选择timestamp，因为timestamp只有4个字节，而datetime8个字节。同时timestamp具有自动赋值以及自动更新的特性

   	   ③ 建立索引注意事项
   	   	 1. 索引名称小写,且普通索引以 idx_ 开头,唯一索引以 uniq_ 开头
   	   	 2. 尽量减少单表索引的数量,因为写操作都会去维护一下索引树。
   	   	 3. 经常作为where条件的字段要添加索引。order by，group by的字段建议添加索引
   	   	 4. 合理利用索引,如覆盖索引,复合索引(最左原则)
   	   	 5. 要经常用 explain 来判断索引是否失效.(Using File Sort)(UsingTemporary)

   	   ④ sql语句的优化
   	   	 1. 避免select * ;
   	   	 2. where条件中非等值条件(in、between、<、<=、>、>=)会导致后面的条件使用不了索引。
   	   	 3. 减少sql与数据库交互的次数。(单例)
   	   	 4. 统计表条数的时候用 count(*) 因为mysql中内置的优化手段
   	   	 5. 避免使用存储过程、触发器、函数等(???)
   	   	 6. 使用prepared statement，可以提供性能并且避免SQL注入(???)

   	   ⑤ 范式化、反范式化。

   (4) 为什么分库分表？怎么处理?怎么关联?:

   	     根据业务来垂直和水平分表。

   (5) 架构部署:
   	     主从复制(集群架构):
   	         基于: 三个进程+二进制文件。
   	         原理: master服务器向sleper服务器发送通知我这边有更新了。
   	               sleper这边发起一个进程用来向主服务器来拉取二进制日志。
   	               sleper通过发起一个进程来实现这个二进制日志
   	     问题: 主从延迟

   (6) sql 子查询
   	   介绍: 把一个查询的结果在另一个查询中使用就叫子查询
   	   分类: 
   	   	①独立子查询
			就是子查询可以独立运行,与外层不存在任何联系的
		②相关子查询
			就是子查询中引用了父查询中的结果；父查询进行一次，子查询才进行一次
	   与操作符连用:
		   	表名:  table1表:        table1:

			字段:	s1字段			 s2

			数据:	 2				 5

				 	 10				 12
	      ① ANY  
	      	介绍: ANY 关键字必须接在一个比较操作符的后面，表示与子查询返回的任何值比较为 TRUE ，则返回 TRUE 
	      	使用：SELECT s1 FROM table1 WHERE s1 > ANY (SELECT s2 FROM table2)
	      	     结果: s1 => 10
	      	课外知识点: IN 是 （ = ANY ） 的别名
	      	特殊点: 
				1.如果 table2 为空表，则 ANY 后的结果为 FALSE （结果为空）
		  ② ALL  
		  	介绍: ALL 关键字必须接在一个比较操作符的后面，表示与子查询返回的所有值比较为 TRUE ，则返回 TRUE
		  	使用: SELECT s1 FROM table1 WHERE s1 > ALL (SELECT s2 FROM table2)
		  		  结果: 没有任何返回结果
		    课外知识点: NOT IN 是 <> ALL 的别名，二者相同
		    特殊情况: 
		    	1.如果 table2 为空表，则 ALL 后的结果为 TRUE
		  ③ EXISTS
		  	如果子查询有结果返回，EXISTS 运算符返回 True，而 NOT EXISTS 则会是相反
		  	SELECT s1 FROM a1 WHERE EXISTS (SELECT s2 FROM a2 where s2 = 5)
		  	结果为: 4 10

   (6) 关键命令:
   		  
   		  建立索引:

   (7) 其他问题:
   		 int(5) 和 int(10)的区别?
   		 前导零

3. redis使用场景?
   
   热点数据的缓存(string)
   	   如: 用户的基本信息
   限时任务的使用。(限时string)
   	   如: 手机验证码
   计数器的使用。(incr / decr)
   	   如: 点赞量，浏览量。
   排行榜相关问题。(zset)
   	   如: 博文排行榜（浏览量）。
   延迟操作:(队列) ？？？
   	   延迟队列服务实现
   模糊查询操作:(???)
   	   通过ZRANGEBYLEX zset - + LIMIT 0 10 可以进行分页数据查询，其中- +表示获取全部数据

   	   zrangebylex key min max 这个就可以返回字典区间的数据，利用这个特性可以进行模糊查询功能，这个也是目前我在redis中发现的唯一一个支持对存储内容进行模糊查询的特性。

   点赞、好友等相互关系的存储(set/交、并、差)
   	   set能够自动排重 可以将两个人的好友都存进去。然后共同好友
   秒杀(？？？)

4. php的各种缓存的使用?
   
   (1)全页面静态化缓存

   	  使用在后台管理系统中。

   	  步骤① 第一次访问页面的时候写入到html文件中
   	        通过 ob_start() 代码块 ob_get_contents()获取内容 
   	        -> file_put_content()写入文件
   	        -> ob_end_clean 删除缓冲区内容并关闭缓冲区
   	  步骤② 第二次进入的时候 先判断静态文件是否存在 如果存在则访问。函数（file_exists()）
   	  		通过判断上次文件修改的时间来判断是否有效。函数（filemtime）

   (2)页面部分缓存

      tp中使用: 在全局静态页中 加入ajax

   (3)数据缓存

      商城中的某个商品信息，当用商品id去请求时，就会得出包括店铺信息、商品信息等数据，此时就可以将这些数据缓存到一个php文件中，文件名包含商品id来建一个唯一标示；下一次有人想查看这个商品时，首先就直接调这个文件里面的信息，而不用再去数据库查询；其实缓存文件中缓存的就是一个php数组之类；

   (4)查询缓存

      将数据存入到redis中并  设置过期时间

   (5)按内容变更进行缓存

      当数据发生变化的时候将缓存进行清除

   (6)Opcode缓存

      php 的流程是 将代码编异成 opcode码然后执行。这时候我们将这个opcode缓存下来，下次在进行对应操作的时候直接走opcode码不用再走中间的流程了。
   
5. 接口安全问题?
   (1) token授权机制 (已实践)
   		 1. 客户端传递 用户名，密码。 服务器对这些进行加密生成token
   		 2. 客户端请求的时候就要传递token，服务器端验证是否一致
   (2) 时间验证机制(已实践)

   		 1. 客户端请求的时候将请求是的时间加上。服务器比对后如果超过一定时间则无效。
   (3) 签名机制(已实践)

   		 1. 客户端这边请求的时候 将以排序加密的形式将 token 时间戳 约定好的key 加密出来一个sign签名。然后传递服务器，服务器以相同的排序加密手法进行生成签名比对。
   (4) sql注入 (已实践)
   		介绍: 是通过sql能够嵌套的特性来进行攻击的。
   		框架中可以配置使用那些函数来防止sql注入。
   		① 通过转义sql语句中的特殊字符 mysql_real_escape_string()
   		② 配置文件中magic_quotes_gpc开启 可以简单的转义 当然也不能重启mysql ，可以用addslashes() 
   		③ 网上的一些自定义函数也是用来过滤转义的。
   		④ 使用pdo的预处理 
   		  这里是先将sql语句预显编译并生成查询计划。后面你传的什么参数都不会影响这个语法结构了。
   (5) xss攻击(已实践)

   		将一些数据输入到网站中。
   		它能够:
	   		烦人的弹窗
			刷新或重定向
			损坏网页或表单
			窃取cookie
			AJAX（XMLHttpRequest）
		   使用php的 htmlentities() 函数过滤
   (6) 会话攻击(已实践)
   		① 会话劫持
   			攻击者通过分析cookie、url来获取session_id 进而实现会话操作。
   			防御: 
   				①更改session名称:(1)在配置文件中session_name = '***';
   							    (2)动态的在session_start()前设置session_name()
   				②关闭透明化session_id , 我们可以post传送。
   				③HttpOnly=true 则拒绝js脚本
   				④将地址栏session_id 编码，服务器在转回来
   				⑤使用ssl
   		② 会话固定
   			就是钓鱼攻击。
   			案例 ： 
   				1.Mallory先打开一个网站http://unsafe，然后服务器会回复他一个session id。比如SID=mjg4qid0wioq。Mallory把这个id记下了。 
				2.Mallory给Alice发送一个电子邮件，他假装是银行在宣传自己的新业务，例如，我行推出了一项新服务，率先体验请点击：http://unsafe/?SID=mjg4qid0wioq，SID后面是Mallory自己的session id。 
				3.Alice被吸引了，点击了 http://unsafe/?SID=mjg4qid0wioq，像往常一样，输入了自己的帐号和口令从而登录到银行网站。 
				4.因为服务器的session id不改变，现在Mallory点击 http://unsafe/?SID=mjg4qid0wioq 后，他就拥有了Alice的身份。可以为所欲为了。 

			防御: 在用户登录成功后重新创建一个session id
   (7) CSRF攻击(已实践)
    	  1.首先用户C浏览并登录了受信任站点A；
  		  2.登录信息验证通过以后，站点A会在返回给浏览器的信息中带上已登录的cookie，
  		    cookie信息会在浏览器端保存一定时间（根据服务端设置而定）；
  		  3.完成这一步以后，用户在没有登出（清除站点A的cookie）站点A的情况下，访问恶意站点B；
  		  4.这时恶意站点 B的某个页面向站点A发起请求，而这个请求会带上浏览器端所保存
  		    的站点A的cookie；
  		  5.站点A根据请求所带的cookie，判断此请求为用户C所发送的。

  		  防御: 
  		  	1、尽量使用POST，限制GET
  		  	2、将cookie设置为HttpOnly  : 防止攻击者使用js获取cookie
  		  	3、增加token ： 请求的时候都加一个随机的token参数 然后服务器进行验证。| 通常使用
  		  	4、通过Referer识别 ： header头中有一个字段叫Referer记录了该HTTP请求的来源地址
  		  						String referer = request.getHeader("Referer");
   (8) 代码注入(已实践)
   (9) sql盲注(???)

6. http、tcp协议原理及应用?
   http：
   	  介绍:
   	  默认端口: 80
   	  请求类型: GET / POST / PUT / DELETE / HEAD / MOVE

7. memcache 和 mangodb?
   memcache:
       端口号:
            11211
       操作:
   	   		设置: set
   	   		获取: get

8. 高并发怎么处理?  
   (1)前端
   	  ① 尽量减少http请求数: 合并文件(laravel前台资源管理)
   	  ② 减少DNS查找(20ms) 将内容资源尽可能放在同一个域下面。
   	  ③ 避免重定向(post请求服务器->服务器302给浏览器->浏览器在跳) 可以使用a链接;
   	  ④ 减少DOM节点(复杂的页面解析的时候也会慢)
   	  ⑤ 杜绝404(不必要去访问一个没用的)
   	  ⑥ 去除重复的脚本(有时候会出现这种情况,要一个就行了)
   	  ⑦ 将js和css文件放在外面。(因为请求的文件会被缓存在浏览器)
   	  ⑧ 清除不必要的cookie数据
   	  ⑨ 异步请求 当用户触发了什么请求什么(ajax) (因为有些东西用户不去看:多级评论)
   	  ⑩ cdn加速(将静态文件、大文件数据放在临近的cdn节点中)
   (2)后端
   	  ① 静态页缓存。
   	  ② 数据缓存
   	  ③ 逻辑处理
   (3)架构
   		负载均衡:
   			原理: 系统扩展分为横向(+服务器)和纵向(增强单机的硬件)；
   			作用: 
	   			1.解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）；
				2.提供故障转移，实现高可用；
				3.通过添加或减少服务器数量，提供网站伸缩性（扩展性）；
				4.安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）
			实现:
				(1)http重定向
				   C请求调度器 -> 调度器随机返回一个服务器地址给C -> C再去请求
				   优点: 简单 好理解。
				   缺点: 后边的服务器坏了都不知道。请求就会失败
				(2)DNS负载均衡
			       一个域名映射多个ip地址。通过dns分配来实现负载均衡。
			       一般dns对应的是一个同样提供负载均衡的服务器.
			       优点:
			       	   实现简单，服务器不需要修改任何代码。
			       缺点:
			       	   DNS是多级解析的,每一级都可能缓存A记录。当某台服务器下线，需要较长的时间才能生效。这段时间内，用户仍然会访问到下线的服务器，导致访问失败
			    (3)反向代理、负载均衡Nginx配置
			        upstream tomcatserver1 {  
					    server 192.168.72.49:8080;  
					    server 192.168.72.49:8081;  
				    }   
				    server {  
				        listen       80;  
				        server_name  8080.max.com;  
				        #charset koi8-r;  
				        #access_log  logs/host.access.log  main;  
				        location / {  
				            proxy_pass   http://tomcatserver1;  
				            index  index.html index.htm;  
				        }  
				     } 
				    通过以上配置，便可以实现，在访问8080.max.com这个网站时，由于配置了proxy_pass地址，所有请求都会先通过nginx反向代理服务器，在服务器将请求转发给目的主机时，读取upstream为 tomcatsever1的地址，读取分发策略，配置tomcat1权重为3，所以nginx会将大部分请求发送给49服务器上的tomcat1，也就是8080端口；较少部分给tomcat2来实现有条件的负载均衡，当然这个条件就是服务器1、2的硬件指数处理请求能力。 

				    1）down

					    表示单前的server暂时不参与负载

					2）Weight

					    默认为1.weight越大，负载的权重就越大。

					3）max_fails

					    允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误

					4）fail_timeout

					    max_fails 次失败后，暂停的时间。

					5）Backup

					    其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。
			    (4)ip负载均衡
			       步骤1:C端像调度器公布的ip地址发出请求
			       步骤2:请求达到调度器,调度器先找一下hash表中是否有C端对应的ip服务器	
			       		 ,没有的话会分配一个ip给这个C端，k-v存在hash表里
			       步骤3:以后这个C端再来的时候就会请求对应的ip服务器
   (4)限流
   	  nginx配置: 
   	  	1.limit_conn_zone
   	  	2.limit_req_zone
   	  	3.ngx_http_upstram_module
   (5)数据库
   	  索引 (避免索引失效)
	  SQL语句优化 
	  存储引擎优化 
	  表结构设计优化 
	  数据库服务器架构优化 (主从) 
	  读写分离 (主从复制 三个线程。)

9. 配置文件操作?
   nginx
   apache
   mysql
   php
     (1) session配置:
         ① 设置session_id  session.name = PHPSESSID
         ② 如果禁用了cookie,可以设置session.use_trans_sid = 0
         ③ 设置保存位置 session.save_path="D:\phpStudy\PHPTutorial\tmp\tmp"
         ④ 设置保存session_id的cookie的过期时间session.cookie_lifetime="n" （秒）
         ⑤ session存储方式: session.save_handler = [files|redis]

     (2) cookie配置

10. 什么是跨域?怎么处理?
	介绍: 被同源策略限制的都叫做跨域，域名，端口，协议一只就要同源策略
	处理方法:
		(1) jsonp
		(2) 代理(雅虎代理、nginx反向代理)
		(3) heder头(服务器修改头文件，来允许跨域)
		(4) windows.name

11.写时复制(引用变量)
   在变量赋值的时候,如$a =1 ; $b = $a; 这时候$b 并没有开辟空间,而是引用了$a;
   在什么时候会开辟一个空间呢? 在$b 被赋予新值的时候。

12.地址栏输入一个链接这个流程怎么走的?
   ① 在地址栏上输入一个域名。按回车
   ② 浏览器会先找本地host文件来解析对应ip
     (host文件存了 域名 与 ip的对应关系。)
     (
     	为什么要找ip?
     		我们打开一个网页的时候使用http协议,而http是基于tcp协议的应用层的协议。
     		所以进行http通信要知道ip
     )
     找到ip则尝试建立与ip对应的服务器的链接。
   ③ 找不到ip则去dns根服务器找,这里DNS可能会给你说让你去其他DNS服务器找。(树状结构)
   ④ 最终找到建立tcp链接。在基于tcp建立http链接,向主机发送http请求
   ⑤ 服务器接到请求后,监听80端口,因为http默认是80.
     (
     	端口的意义:
     		ip是用来找目标主机服务器的。
     		端口是用来找服务器里面的应用程序的。
     )
     接着对这个http请求做一个解析。将解析出来的数据发送给php处理,php处理完成后返回对应结果给
     nginx,nginx在返回给客户端。
   ⑥ 客户端浏览器对这个返回的数据做一些处理。如返回的是html则逐行解析。
     如果遇到js文件图片等资源、则再次发送请求服务器

13.静态属性的好处
   生命周期: 整个脚本流程。
   静态变量: 静态区(类共享)，存储静态变量。静态区访问的更快一点。
   成员属性: 独立的空间。
   单例: 
   	   目的: 运行过程中只创建一个实例。 
   	   场景: 创建一个链接。如mysql链接
   	   基于: 静态变量。不会出现多个。将对象实例挂载静态变量上来供整个生命周期来使用
   好处: 只存在一份,所以节省空间，调用方便。

14.linux权限问题

   目录写权限: 是否能够cd进去
   目录读权限: 是否能够查看
   目录执行权限:是否能够增删

15.php、nginx运行原理

	www.example.com        
				|
				|
			Nginx  (反向代理)      
				|
				|
	路由到www.example.com/index.php      
				|
				|
	加载nginx的fast-cgi模块  (fast-cgi 约定好php解析器和webserver的通信)     
				|
				|
	fast-cgi监听127.0.0.1:9000地址    .
				|
				|
	www.example.com/index.php请求到达127.0.0.1:9000  (webserver向php发送一个请求)
				|
				| 
	php-fpm 监听127.0.0.1:9000  (fpm : fast-cgi管理器)
				|
				|
	php-fpm 接收到请求，启用worker进程处理请求 (每一个worker进程上都挂着一个php解析器)    
				|
				|
	php-fpm 处理完请求，返回给nginx        
				|
				|
	nginx将结果通过http返回给浏览器
   **********************************************************************************************
   cgi 和 fast-cgi:
       详细网址: https://blog.csdn.net/zjuwangleicn/article/details/79300347
   	   cgi协议: 
   	      作用: 解决了php解释器与webserver通信的问题
          流程: webserver每收到一个请求，都会去fork一个cgi进程，请求结束再kill掉这个进程
          缺点: 这样有10000个请求，就需要fork、kill php-cgi进程10000次
       fast-cgi:
          fast-cgi每次处理完请求后，不会kill掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。
   php-fpm是什么:
        php-fpm即php-Fastcgi Process Manager.（fast-cgi进程管理器）
		php-fpm是 FastCGI 的实现，并提供了进程管理的功能。
		进程包含 master 进程和 worker 进程两种进程。
		master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。

   *********************************************************************************************

   Zend引擎:
       介绍: Zend整体用纯C实现，是PHP的内核部分，它将PHP代码翻译（词法、语法解析等一系列编译过程）为可执行opcode的处理并实现相应的处理方法、实现了基本的数据结构（如hashtable、oo）、内存分配及管理、提供了相应的api方法供外部调用，是一切的核心，所有的外围功能均围绕Zend实现。
       将源文件转换成机器语言，然后在虚拟机上运行它
       --------------------- 
   Extensions:
       围绕着Zend引擎，extensions通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如array系列）、标准库等都是通过extension来实现，用户也可以根据需要实现自己的extension以达到功能扩展、性能优化等目的（如贴吧正在使用的PHP中间层、富文本解析就是extension的典型应用）
	   --------------------- 
   Sapi：
       Sapi全称是Server Application Programming Interface，也就是服务端应用编程接口，Sapi通过一系列钩子函数，使得PHP可以和外围交互数据，这是PHP非常优雅和成功的一个设计，通过sapi成功的将PHP本身和上层应用解耦隔离，PHP可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式

       apache2handler：这是以apache作为webserver，采用mod_PHP模式运行时候的处理方式，也是现在应用最广泛的一种。

	   cgi：这是webserver和PHP直接的另一种交互方式，也就是大名鼎鼎的fastcgi协议，在最近今年fastcgi+PHP得到越来越多的应用，也是异步webserver所唯一支持的方式。

	   cli：命令行调用的应用模式
	   --------------------- 
   上层应用:
       这就是我们平时编写的PHP程序，通过不同的sapi方式得到各种各样的应用模式，如通过webserver实现web应用、在命令行下以脚本方式运行等等

16.mb开头的函数
   (1)substr(string,start,length) 把string从start位置开始截取length这么长但是截取不了中文

      mb_substr( $str, $start, $length, $encoding )

      参数介绍: ($encoding，网页编码，如utf-8,GB2312,GBK)

      用法:  echo mb_substr('这是一个长长的字符串来截我吧。',0,6,'utf-8');
     		 结果是：这是一个长长.
      总结:  mb_substr()是将一个汉字看做一个下标来截取的
    (2)strlen()
       mb_strlen()

    总结: mb就是让函数对不同字符编码进行处理。mb针对的是字符编码

17.linux
   
18.小程序
   (1) 登录流程:
		wx.login() 获取code 这个code就像当于一个验证码
		然后我们发送到我们后台。我们后台再通过微信的开发接口将这个code+appid+appsecret发送给微信后台
		微信后台收到之后会给用户一个提示信息是否同意,授权成功微信服务器会返回openid和session_key(用于解密用户的隐私信息)
		然后将这个openid保存起来。并返回一个token 用于小程序的接口请求
 
		colorUI
    
19.QPS/PV/UV/吞吐量/响应时间/带宽?

   QPS：每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求数(指HTTP请求)

   吞吐量：单位时间内处理的请求数量(通常由QPS与并发数决定)

   响应时间：从请求发出到收到响应花费的时间，例如系统处理一个HTTP请求需要100ms，这个100ms就是系统的响应时间

   PV：综合浏览量(Page View)，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量，同一个人浏览你的网站同一页面，只记作一次PV

   UV：独立访问(UniQue Visitor)，即一定时间范围内相同访客多次访问网站，只计算为1个独立访客
   带宽：计算带宽大小需关注两个指标，峰值流量和页面的平均大小、

20.秒杀

21.正则
        作用：分割 查找 匹配 替换字符串
        分隔符 / # ~ 
        通用原子:\d \w \s空白符 \D除下0-9以外的 \W 除下字母数字下划线 \S 除下空白符
        元字符: . 除下换行的任意字符
             * 匹配前面的内容多次
             + 1次多次
             {n} n次
             {n,} n次或多次
             {n,m}
             [abc]集合 a或者b 或者c
             （）当做一个整齐
             [^a]取反 代表除下a
             | 或者的意思 
             [-] 代表范围 如:[0-9] 代表0到9  
             i 不区分大小写
             u 做utf8中文匹配的时候用到 
        后向引用: preg_replace()

其他问题:
	1.说一说什么是静态后期绑定
	  	转发调用
			所谓的 “转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::, parent::, static:: 以及 forward_ static _call ()。即在进行静态调用时未指名类名的调用属于转发调用。

		非转发调用
			非转发调用其实就是明确指定类名的静态调用（foo::bar ()）和非静态调用 ($foo->bar ())。即明确地指定类名的静态调用和非静态调用。

	    非转发调用类

	    详解:https://learnku.com/articles/8964/understanding-of-static-binding-at-the-later-stage-of-php
	2.接口 Interface 的作用
	3.影响 php 性能的几个方面
	  ① 代码:
		  (1) 代码的繁琐,冗余。多使用PHP内置的变量、常量、函数。
		  (2) 少用魔术方法
		  (3) 错误抑制符'@'最好不用 
		  (4) 合理使用内存 如unset() 前 将变量=NULL
		  (5) include 尽量使用绝对路径
	  ② 数据库不合理使用
	  ③ 服务器配置低
	  ④ 大量的图片,外链。
	4.说说对 php gc 的理解(垃圾回收机制)
	5.如何改变匿名函数 Closure 的作用域
	  使用use()
	  use意思是连接闭包和外界变量,从父作用域继承变量
	6.php7 了解多少 以及你对哪个新特性最感兴趣
	  (1) 简写三元运算符  ??
	  (2) 类型约束
		      严格模式:
		              declare(strict_types=1);  
		      		  1表示严格类型校验模式，作用于函数调用和返回语句；
		      		  0表示弱类型校验模式
		  	  强制模式：
		  	  		  如: function demo(int $a) 严格模式1下必须类型一致
		  	  									严格模式0下可以转一下类型
		      返回类型声明:
		      		  如: function demo(int $a): int
			      		  {
			      		  	  return $a;
			      		  }
			      	      在严格模式1下返回类型必须一致
			      	      在严格模式0下放回烈性可以转
	  (3) 太空船运算符(组合运算符)
	   	   <=>  小于返回-1  等于放回0 大于返回1
	  (4) 5.6 只能通过const定义常量数组, 7也可以通过define()
	  (5) 匿名类 
	          特点: 和匿名函数意思一样。类能用的功能它都能用
	          实现方式：https://coderschool.cn/1958.html
	  (6) Closure::call() 
		      更好的将一个闭包函数绑定到一个新的对象实例上并调用执行该函数
		      地址:https://www.runoob.com/php/php-closure-call.html
	  (7) 安全的随机数
	   		random_bytes(int $val);
	   		random_int(int $start,int $end);
	  (8) 提供更安全的反序列化
	  (9) 命名空间和use引用优化
			// PHP7以前语法的写法 
			use FooLibrary\Bar\Baz\ClassA; 
			use FooLibrary\Bar\Baz\ClassB; 
			// PHP7新语法写法 
			use FooLibrary\Bar\Baz\{ ClassA, ClassB};
			// PHP 7 之前版本需要使用多次 use 
			use some\namespace\ClassA; 
			use some\namespace\ClassB; 
			use some\namespace\ClassC as C;
			// PHP 7+ 之后版本可以使用一个 use 导入同一个 namespace 的类 
			use some\namespace\{ClassA, ClassB, ClassC as C};  
	  (10) 异常和错误
	  (11) 增加了intdiv()函数,接收两个参数,返回值为第一个除于第二个然后取整返回.
	  (12) session_start()函数可以接收一个数组用来作为参数。用于动态配置php.ini
	  废弃的:
	  	1.以静态的方式调用非静态方法
	  废弃的扩展:
	  	1.mysql 
	7.cookie/session 的生命周期
	  对于cookie:
		  ①cookie是创建于服务器端保存于浏览器端

		  ②cookie的生命周期可以通过cookie.setMaxAge(2000);来设置，如果没有设置setMaxAge,

		   则cookie的生命周期当浏览器关闭的时候，就消亡了

		  ③cookie可以被多个同类型的浏览器共享  可以把cookie想象成一张表
	  
	   两者区别:
	      ①存在的位置：
	         cookie 存在于客户端，临时文件夹中
			 session：存在于服务器的内存中，一个session域对象为一个用户浏览器服务
		  ②安全性
		     cookie 在客户端安全性低，可以通过加密等方式加强安全性
		     session 安全性高
		  ③网络传输量
		  	 cookie 在客户端需要传
		  	 session 在服务器不用传
		  ④生命周期(以20分钟为例)
		     cookie是累计的,从创建的时候开始计时,20分钟后过期
		     session是间隔的,从创建开始如果中间有访问session则重新计算session的生命周期
		     ***关机会造成session生命周期的结束，但是对cookie没有影响

		session_id传递的三种方式:
			1. cookie 携带默认；
			2. url传参
			3. 表单隐藏域

	    session是怎么存的：
	        默认:sess_前缀+session_id为文件名。文件内容就是对应的数据。

	    session存其他位置
	    	存redis:
	    		1. 配置php.ini  
	    		   (session.save_handler= redis)
	    		   (session.save_path = "tcp://127.0.0.1:6381")需要用到tcp来连接redis
	    		2. 存储方式:
	    		   PHPREDIS_SESSION: 前缀，再加上session_id 的形式，是一个string 字符串类型，带生存周期的

	    session 使用经验
	        Session中保存的数据的大小要考虑到存储上线不论是内存还是数据库
			Session中不要存储不可恢复的内容
			依赖Session的关键业务一定要确保客户端开启了Cookie
			注意Session的过期时间
			在负载均衡的情况下，由于存在Web服务器内存中的Session无法共享，通常需要重写Session的实现。
	8.什么情况下设置 header 头会失效
      1. header("location:test.php")
         ① location和“:”号间不能有空格，否则会出错。
         ② 在用header前不能有任何的输出
	9.ob_start 系列的作用,以及在项目中都怎么用过
	    //开启输出缓冲区
		ob_start(); 
		//获取输出缓冲区内容
		ob_get_contents();
		//清空（擦掉）输出缓冲区
		ob_clean();
		//送出输出缓冲区内容并关闭缓冲
		ob_end_flush();
		//得到当前缓冲区的内容并删除输出缓冲区
		ob_get_clean();
	10 !empty($varable)和 isset($varable)的区别
	   isset()判断变量是否为NULL,is_null() 与之相反
	   empty()
	          数值型(int,float)0
	          String '' , "0"
	          布尔类型false
	          空数组[],   ([[]])返回false
	          NULL
	11 请说出几种接受外部变量的方式
	   (1)$GLOBALS
	   (2)use (匿名函数使用)
	   (3)用global定义
	   (4)参数传递

  12 mysql 将时间戳直接转换成日期时间，mysql查询某一天的数据。
  
      FROM_UNIXTIME( ):转为时间戳类型时间
      UNIX_TIMESTAMP( ) :返回长整形类型时间

          SELECT * FROM yi_order
          WHERE FROM_UNIXTIME( datein,  '%Y-%m-%d' ) =  "2015-03-14"
          LIMIT 0 , 30
      datein 字段是php中用time()函数生产的字符串，

      上面那个语句就是查询时间为2015-03-14的所有订单。

其其他问题:

	小程序与js的区别

	关注公众号对小程序获取个人信息有什么影响吗

	awk 

	中间件 





    git
    laravel
    php各种组件
        1. php-excel
        2. phpmailer
        3. 
    mysql 
    小程序



    第一题
    array_chunk — 将一个数组分割成多个
	array_column — 返回数组中指定的一列
	array_combine — 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值（另一种意义的合并数组）
	array_flip — 交换数组中的键和值
	array_key_exists — 检查数组里是否有指定的键名或索引
	str_replace — 子字符串替换
	str_ireplace — str_replace 的忽略大小写版本
	str_repeat — 重复一个字符串
	str_shuffle — 随机打乱一个字符串
  array_filter() -- 数组去除空值


	常见状态码
	200 - 请求成功
	301 - 资源（网页等）被永久转移到其它URL
	302 - 临时重定向
	404 - 请求的资源（网页等）不存在
	500 - 内部服务器错误

	第六题
	select uname from order where TO_DAYS(addtime) = TO_DAYS(NOW()) order by price desc limit 10

    第七题
	select username from user where length(username) = (select max(length(username)) from user)






laravel 队列:
    // 这个任务将被分发到默认队列...
    Job::dispatch();

    // 这个任务将被发送到「emails」队列...
    Job::dispatch()->onQueue('emails');










    创建一个任务类 。 这就是一个任务。

    handle方法是执行任务 。 构造方法是初始化一些东西

    分发任务:

      dispatch(任务类的实例)

    延迟分发:

      delay()
      ProcessPodcast::dispatch($podcast)
                ->delay(Carbon::now()->addMinutes(10)); --> 10分钟不能被处理

    工作链:

      withChain()
      ProcessPodcast::withChain([
          new OptimizePodcast,
          new ReleasePodcast
      ])->dispatch();

    分发任务到指定队列

       ProcessPodcast::dispatch($podcast)->onQueue('processing');

    分发任务到指定连接

       ProcessPodcast::dispatch($podcast)->onConnection('sqs');

    最大尝试次数
       php artisan queue:work --tries=3

       /**
         * 任务最大尝试次数。
         *
         * @var int
         */
        public $tries = 5;

        /**
         * 任务运行的超时时间。
         *
         * @var int
         */
        public $timeout = 120;

        /**
         * 定义任务超时时间 
         *
         * @return \DateTime
         */
        public function retryUntil()
        {
            return now()->addSeconds(5);
        }

    运行队列处理器
        所有任务
        php artisan queue:work
        单个任务
        php artisan queue:work --once
        指定连接
        php artisan queue:work redis
        指定队列
        php artisan queue:work redis --queue=emails
    
    注意:
      一定要记得，队列处理器是长时间运行的进程，并在内存里保存着已经启动的应用状态。这样的结果就是，处理器运行后如果你修改代码那这些改变是不会应用到处理器中的。所以在你重新部署过程中，一定要 重启队列处理器 。

      资源注意事项
        守护程序队列不会在处理每个作业之前 「重新启动」 框架。因此，在每个任务完成后，您应该释放任何占用过大的资源。例如，如果你使用 GD 库进行图像处理，你应该在完成后用 imagedestroy 释放内存

    设置队列优先级
       
       php artisan queue:work --queue=high,low

    重启所有队列处理器
       
       php artisan queue:restart

    任务过期

        config/queue.php 配置文件里，每一个队列连接都定义了一个 retry_after 选项。这个选项指定了任务最多处理多少秒后就被当做失败重试了。比如说，如果这个选项设置为 90，那么当这个任务持续执行了 90 秒而没有被删除，那么它将被释放回队列。通常情况下，你应该把 retry_after 设置为最长耗时的任务所对应的时间。

    队列处理器超时

        php artisan queue:work --timeout=60

    没有新任务处理器睡眠时间

        php artisan queue:work --sleep=3

    处理失败的任务

        queue:failed-table

        加最大尝试次数 --tries
        php artisan queue:work redis --tries=3

    清除失败的任务

        任务类中定义一个 failed 方法，它可以允许你在一个任务失败后清除它

    重试失败的任务

        php artisan queue:failed   | queue:failed 命令会列出任务 ID ，队列，以及失败的时间
        php artisan queue:retry 5  | 重试一个任务 ID 为 5 的任务
        php artisan queue:retry all  | 要重试所有失败的任务
        php artisan queue:forget 5 | 删除一个失败的任务
        php artisan queue:flush | 要清空所有失败的任务

    任务事件
        前置 和 后置

         
构造函数 可选，用来传参
handle（） 必选，实现队列任务逻辑
failed() 可选，当任务失败时执行